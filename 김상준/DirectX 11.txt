DirectX 11 Engine Tutorial
Visual Studio 세팅:
- Windows Desktop Wizard로 프로젝트 생성 -> Windows Application(.exe)로 생성 (빈 프로젝트)
- DirectXTK를 깃허브에서 다운 -> 알맞은 버젼을 열기 -> Debug, Release 각각 x64, x86으로 한번 씩 빌드 -> Inc, Bin 폴더 생성
- Inc 폴더를 복사해 DirectX 11 프로젝트 폴더에 붙여넣기
- Libs 폴더를 만들어 내부에 x64, x86 폴더 생성. 후에 각 폴더에 Debug, Release 폴더 생성
- Bin 폴더에서 폴더에 맞게 DirectXTK.lib 파일을 복사 붙여넣기
- 이후 프로젝트 속성 -> VC++ 디렉터리 -> 구성, 플랫폼 모두 All로 바꿔줌 -> 포함 디렉터리에 Includes 폴더 넣기
- 구성, 플랫폼을 바꿔가면서 라이브러리 폴더를 넣어줌
- #pragma comment(lib, "d3d11.lib"), #pragma comment(lib, "DirectXTK.lib")를 해주고 작동하는지 확인

윈도우 세팅:
- StringConverter 헤더와 cpp 파일 생성 (string을 wstring으로 변환)
- ErrorLogger 헤더와 cpp 파일 생성 (에러 체킹)
	-> HRESULT는 함수가 성공했는지 여부를 리턴, _com_error(comdef.h 에 포함됨) 변수로 받을 수 있고 ErrorMessage()를 사용하면 wstring으로 에러메시지를 받는다.
- RenderWindow 헤더와 cpp파일 생성 (윈도우 창을 만드는 클래스 생성 -> WinAPI와 거의 동일)
- WindowContainer와 Engine 헤더, cpp 파일 생성
	-> Engine은 "윈도우 창 셋업"과 "그래픽(DirectX) 셋업"을 같이하기 위해 만드는 클래스
	-> WindowContainer는 여러 윈도우 기능들을 넣어놓기 위함 (Mouse, Keyboard, WndProc 등)
	-> 이 강의에선 WindowContainer를 상속하는 객체(즉 Engine)의 포인터를 CreateWindowEx함수에 넣어주고 싶음
	-> 그리고 그 포인터를 WM_NCCREATE에서 찾고자 함 (그것을 HandleMessageSetup에서 함) -> lParam에 저장되어 있는 CreateWindow정보를 불러옴
- KeyboardEvent 와 KeyboardClass 헤더, cpp 파일 생성
- MouseEvent 와 MouseClass 헤더, cpp 파일 생성
	-> 세팅 이후엔, WindowContainer에 Mouse와 Keyboard의 객체를 저장
	-> 키보드와 마우스 객체를 만들어 메시지가 발생하면 해당 정보를 그 객체에 저장하는 것. 그리고 queue에 객체를 저장
	-> 저장된 메시지는 엔진을 Update할 때 queue에서 객체를 pop하고, 해당 객체의 정보를 가져와 실행
	-> WM_INPUT은 직전 인풋과의 "상대적 차이"를 구할 수 있음
		-> 이것을 하기 위해선 WindowContainer 생성자에서 RegisterRawInputDevice를 먼저 해주어야함

DirectX 개요:
- Component Object Model (COM)
	- Binary Compatibility: Run the same software without requiring that the application be recompiled
		-> 컴파일러의 binary 작동방식이 다르다면 (ex. MSVC vs GCC), 한 컴파일러가 다른 컴파일러의 .dll을 불러왔을 때 제대로 구동이 안될 것
	- COM의 목표: Binary Compatibility 구현을 위해 ("재사용가능한" 바이너리 소프트웨어 객체를 만들어 recompile이 필요하지 않도록)
	- 특정 프로그래밍 언어에 국한되지 않음, 자원(메모리) 할당에 사용가능, 객체 생성에도 사용가능 ("Interface"로 제공)
	- Factory 함수를 불러 COM 객체를 만들고, COM은 우리에게 Interface를 제공하여 해당 객체를 사용할수 있음
	- 기본적 기능들: IUnknown Interface -> AddRef, Release, QueryInterface / UUID를 이용해 COM interface를 구분
- D3D Architecture
	- Device: 그래픽 어답터 (그래픽 카드)를 칭함 / 셋업을 위해 사용됨
	- Swap Chain: Double Buffer를 사용
		-> Front에는 완료된 작업만을 두고 모니터는 여기를 읽음, Back에서 유저가 렌더링을 하고 완료될 때 까지 보여지지 않음
	- Device Context: 실제 그리기를 위해 사용됨 (Issue rendering commands, configuring rendering pipeline
	- Render Target View: Swap Chain의 어떤 버퍼에 렌더링 할지 결정 (보통 Back에 함)
- DirectX 11 Graphics Pipeline
	- 1) Input Assembler Stage: 유저가 채운 버퍼에서 원시 데이터들을 읽어오고, 다른 스테이지에서 쓰일 Primitive type(line list, triangle strip 등)으로 assemble하는 단계
	- 2) Vertex Shader Stage: Input Assembly에서 온 데이터들을 처리하는 과정 (Transformation, skinning, morphing 등), single input vertex에 대해서만 작용 됨.
	- 3) Tessellation Stages: low detail 모델을 high detail로 렌더링하는 단계,  Hull-Shader / Tessellator / Domain-Shader의 총 세 단계로 이루어짐
	- 4) Geometry Shader Stage: Vertex Shader 단계와는 다르게 full primitive에 대한 계산을 진행
	- 5) Rasterizer Stage: 벡터 정보들을 raster image (셀마다 특정값을 일정한 수치로 표시하는 격자 형식의 자료 구조)로 변환하는 단계
	- 6) Pixel Shader Stage: 고급 픽셀 쉐이딩 단계 (per-pixel lighting, postprocessing 등)
	- 7) Output-Merger Stage: 모든 픽셀정보를 종합하여 최종 렌더 이미지를 생성하는 단계

DirectX 11 세팅:
- Graphics 헤더, cpp 파일 생성
- AdapterReader 헤더, cpp 파일 생성
	-> DirectX 초기화를 위해, 먼저 비디오 어답터(그래픽 카드)를 가져오기 위한 클래스
	-> 모두 세팅 이후엔 WindowContainer에 Graphics 객체를 담고, Engine의 Initialize에서 Graphics를 초기화 해주어야 함
- D3D11CreateDeviceAndSwapChain(), SwapChain, RenderTargetView 셋업 -> RenderFrame 함수를 생성해 WinMain에서 Update후 렌더링
- Input Assembler Stage:
	-> D3D11_INPUT_ELEMENT_DESC 설정, device->CreateInputLayout() 으로 생성
- Vertex Shdaer Stage:
	-> 리소스 파일에 vertexshader.hlsl파일 생성
	-> HLSL Tools for VS 다운받기, hlsl파일 속성에서 셰이더 형식 = vs / 모델은 5.0으로 설정
	-> Shaders 헤더, cpp 파일 생성
	-> Graphics 클래스에 VertexShader 클래스 추가하고 vertexshader 초기화