DirectX 11 Engine Tutorial
Visual Studio 세팅:
- Windows Desktop Wizard로 프로젝트 생성 -> Windows Application(.exe)로 생성 (빈 프로젝트)
- DirectXTK를 깃허브에서 다운 -> 알맞은 버젼을 열기 -> Debug, Release 각각 x64, x86으로 한번 씩 빌드 -> Inc, Bin 폴더 생성
- Inc 폴더를 복사해 DirectX 11 프로젝트 폴더에 붙여넣기
- Libs 폴더를 만들어 내부에 x64, x86 폴더 생성. 후에 각 폴더에 Debug, Release 폴더 생성
- Bin 폴더에서 폴더에 맞게 DirectXTK.lib 파일을 복사 붙여넣기
- 이후 프로젝트 속성 -> VC++ 디렉터리 -> 구성, 플랫폼 모두 All로 바꿔줌 -> 포함 디렉터리에 Includes 폴더 넣기
- 구성, 플랫폼을 바꿔가면서 라이브러리 폴더를 넣어줌
- #pragma comment(lib, "d3d11.lib"), #pragma comment(lib, "DirectXTK.lib")를 해주고 작동하는지 확인

윈도우 세팅:
- StringConverter 헤더와 cpp 파일 생성 (string을 wstring으로 변환)
- ErrorLogger 헤더와 cpp 파일 생성 (에러 체킹)
	-> HRESULT는 함수가 성공했는지 여부를 리턴, _com_error(comdef.h 에 포함됨) 변수로 받을 수 있고 ErrorMessage()를 사용하면 wstring으로 에러메시지를 받는다.
- RenderWindow 헤더와 cpp파일 생성 (윈도우 창을 만드는 클래스 생성 -> WinAPI와 거의 동일)
- WindowContainer와 Engine 헤더, cpp 파일 생성
	-> Engine은 "윈도우 창 셋업"과 "그래픽(DirectX) 셋업"을 같이하기 위해 만드는 클래스
	-> WindowContainer는 여러 윈도우 기능들을 넣어놓기 위함 (Mouse, Keyboard, WndProc 등)
	-> 이 강의에선 WindowContainer를 상속하는 객체(즉 Engine)의 포인터를 CreateWindowEx함수에 넣어주고 싶음
	-> 그리고 그 포인터를 WM_NCCREATE에서 찾고자 함 (그것을 HandleMessageSetup에서 함) -> lParam에 저장되어 있는 CreateWindow정보를 불러옴
- KeyboardEvent 와 KeyboardClass 헤더, cpp 파일 생성
- MouseEvent 와 MouseClass 헤더, cpp 파일 생성
	-> 세팅 이후엔, WindowContainer에 Mouse와 Keyboard의 객체를 저장
	-> 키보드와 마우스 객체를 만들어 메시지가 발생하면 해당 정보를 그 객체에 저장하는 것. 그리고 queue에 객체를 저장
	-> 저장된 메시지는 엔진을 Update할 때 queue에서 객체를 pop하고, 해당 객체의 정보를 가져와 실행
	-> WM_INPUT은 직전 인풋과의 "상대적 차이"를 구할 수 있음
		-> 이것을 하기 위해선 WindowContainer 생성자에서 RegisterRawInputDevice를 먼저 해주어야함

DirectX 개요:
- Component Object Model (COM)
	- Binary Compatibility: Run the same software without requiring that the application be recompiled
		-> 컴파일러의 binary 작동방식이 다르다면 (ex. MSVC vs GCC), 한 컴파일러가 다른 컴파일러의 .dll을 불러왔을 때 제대로 구동이 안될 것
	- COM의 목표: Binary Compatibility 구현을 위해 ("재사용가능한" 바이너리 소프트웨어 객체를 만들어 recompile이 필요하지 않도록)
	- 특정 프로그래밍 언어에 국한되지 않음, 자원(메모리) 할당에 사용가능, 객체 생성에도 사용가능 ("Interface"로 제공)
	- Factory 함수를 불러 COM 객체를 만들고, COM은 우리에게 Interface를 제공하여 해당 객체를 사용할수 있음
	- 기본적 기능들: IUnknown Interface -> AddRef, Release, QueryInterface / UUID를 이용해 COM interface를 구분
- D3D Architecture
	- Device: 그래픽 어답터 (그래픽 카드)를 칭함 / 셋업을 위해 사용됨
	- Swap Chain: Double Buffer를 사용
		-> Front에는 완료된 작업만을 두고 모니터는 여기를 읽음, Back에서 유저가 렌더링을 하고 완료될 때 까지 보여지지 않음
	- Device Context: 실제 그리기를 위해 사용됨 (Issue rendering commands, configuring rendering pipeline
	- Render Target View: Swap Chain의 어떤 버퍼에 렌더링 할지 결정 (보통 Back에 함)
- DirectX 11 Graphics Pipeline
	- 1) Input Assembler Stage: 유저가 채운 버퍼에서 원시 데이터들을 읽어오고, 다른 스테이지에서 쓰일 Primitive type(line list, triangle strip 등)으로 assemble하는 단계
	- 2) Vertex Shader Stage: Input Assembly에서 온 데이터들을 처리하는 과정 (Transformation, skinning, morphing 등), single input vertex에 대해서만 작용 됨.
	- 3) Tessellation Stages: low detail 모델을 high detail로 렌더링하는 단계,  Hull-Shader / Tessellator / Domain-Shader의 총 세 단계로 이루어짐
	- 4) Geometry Shader Stage: Vertex Shader 단계와는 다르게 full primitive에 대한 계산을 진행
	- 5) Rasterizer Stage: 벡터 정보들을 raster image (셀마다 특정값을 일정한 수치로 표시하는 격자 형식의 자료 구조)로 변환하는 단계
	- 6) Pixel Shader Stage: 고급 픽셀 쉐이딩 단계 (per-pixel lighting, postprocessing 등)
	- 7) Output-Merger Stage: 모든 픽셀정보를 종합하여 최종 렌더 이미지를 생성하는 단계

DirectX 11 세팅:
- Graphics 헤더, cpp 파일 생성
- AdapterReader 헤더, cpp 파일 생성
	-> DirectX 초기화를 위해, 먼저 비디오 어답터(그래픽 카드)를 가져오기 위한 클래스
	-> 모두 세팅 이후엔 WindowContainer에 Graphics 객체를 담고, Engine의 Initialize에서 Graphics를 초기화 해주어야 함
- D3D11CreateDeviceAndSwapChain(), SwapChain, RenderTargetView 셋업 -> RenderFrame 함수를 생성해 WinMain에서 Update후 렌더링
- Input Assembler Stage:
	-> D3D11_INPUT_ELEMENT_DESC 설정, device->CreateInputLayout() 으로 생성
- Vertex Shader Stage:
	-> 리소스 파일에 vertexshader.hlsl파일 생성
	-> HLSL Tools for VS 다운받기, hlsl파일 속성에서 셰이더 형식 = vs / 모델은 5.0으로 설정
	-> Shaders 헤더, cpp 파일 생성
	-> Graphics 클래스에 VertexShader 클래스 추가하고 vertexshader 초기화
- Rasterizer Stage: InitializeDirectX에서 Viewport설정하고 deviceContext에서 Viewport 세팅
- Pixel Shader Stage:
	-> 리소스 파일에 pixelshader.hlsl 파일 생성 / 속성에서 셰이더 형식 = ps, 모델은 5.0 설정
	-> Shaders 파일에 PixelShader 클래스를 추가하고 VertexShader와 유사하게 셋업
	-> Graphics 클래스에 PixelShader 클래스 추가하고 초기화
- Output-Merger Stage: InitializeDirectX에서 이미 OMSetRenderTargets를 통해 완료.

실제로 그리기:
- VertexShader Coordinate System
	-> 정중앙이 (0,0)이고 x의 범위는 왼쪽에서 오른쪽으로 -1 ~ 1, y의 범위는 아래에서 위로 -1 ~ 1
- Vertex Buffer 생성 후 다양한 topology로 그리기
	-> Graphics 클래스에 vertexBuffer 생성 / InitializeScene() 함수 생성
		-> InitializeScene에서 점 위치 지정
	-> RenderFrame()에서 그리기
		-> deviceContext inputlayout, vertexshader, pixelshader, vertexbuffer 우선 세팅
		-> deviceContext->Draw에서 점 개수 지정 후 그리기
		-> pixelshader.hlsl 파일에서 색 수정 가능
		-> IASetPrimitiveTopology에서 다른 topology 설정 가능

Shader에 컬러 추가하기:
- Vertex 클래스에 색 정보 추가
- vertexshader.hlsl, pixelshader.hlsl 파일 수정
- D3D11INPUT_LAYOUT_DESC 수정, 또한 InitializeScene에서 Vertex를 넣을 때 시계방향으로 넣어주어야 함 (Default Rasterizer 특성)

*************** 대충 이해해본 DirectX가 돌아가는 방식 ***************
- 맨 처음에 InitializeShader는 말 그대로 Initialize 해주는 것 (내 입력이 들어가는 것은 아니다.)
	-> 이 과정에서 hlsl 파일들을 각 shader들과 연결시키고, input layout을 어떤 식으로 구성할지 description을 넣는 것
- 이후 입력 정보를 넣을 구조체를 만들고 (여기선 Vertex.h에 있는 Vertex Class에 해당) 데이터를 넣어준 뒤 vertex buffer를 생성
- 그 다음 RenderFrame()에서 deviceContext와 input layout, shader들을 연결시켜 주고 Draw()해주면
	-> 입력해놓은 input layout에 따라 vertex의 정보들이 분류되고
	-> vertexshader.hlsl에 적힌 코드에 따라 분류된 정보들이 가공되고 pixelshader로 전송
	-> vertexshader로부터 받은 정보들이 마지막으로 pixelshader.hlsl의 코드에 따라 가공되고 최종 출력

Rasterizer State:
- Graphics 클래스에 rasterizerState 생성
- InitializeDirectX에서 viewport 설정 이후 rasterizer state 생성 / 그리고 RenderFrame()에서 deviceContext->RSSetState
- FillMode, CullMode 다양하게 설정 가능

Z-Depth 개요:
- 렌더링 된 물체의 각 픽셀에서 카메라까지의 거리를 z-depth로 표현 (0 ~ 1 사이의 숫자)
- 숫자가 작을수록 카메라와 가까운 것
- 여러가지 물체가 겹쳐서 렌더링 되어 있을 때, 어떤 물체가 앞에서 뒤의 물체를 가리는지 파악 가능

Depth Stencil View:
- 먼저 Graphics 클래스에 depthStencilView & Buffer 생성
- InitializeDirectX에서 viewport 추가 설정 (MinDepth, MaxDepth 추가)
- D3D11_TEXTURE2D_DESC 설정 / depthStencilView & Buffer 설정 / OMSetRendertargets에서 depthStencilView 연결
- RenderFrame()에서 ClearDepthStencilView로 초기화
- Graphics 클래스에 depthStencilState 추가
- InitializeDirectX에서 D3D11_DEPTH_STENCIL_DESC로 depthStencilState 설정
- RenderFrame()에서 OMSetDepthStencilState로 설정
- Vertex 클래스에 z값 추가 / vertex array 수정
- Input layout Format을 R32G32B32로 수정
- vertexshader.hlsl 수정

Render Font:
- MakeSpriteFont.exe로 .spritefont 파일 생성 후 프로젝트 디렉터리에 복사
- Graphics 클래스에 spriteBatch 와 spriteFont 생성
- InitializeDirectX()에서 spriteBatch 와 Font 설정
- RenderFrame()에서 둘을 활용해 텍스트 출력 가능

Fixing Window Dimensions:
- RenderWindow::Initialize 에서 RECT구조체 설정
- GetSystemMetrics를 이용해 화면 중앙의 위치 값을 가져올 수 있음
- AdjustWindowRect()를 이용해 윈도우 크기 설정

Texturing:
- Texture coordinate layout
	-> 좌상단: (0, 0), 우하단: (1, 1)
- Texture 추가 과정
	-> Graphics 클래스에 samplerState 생성
	-> InitializeDirectX에서 samplerState 설정
	-> pixelshader.hlsl과 vertexshader.hlsl에 objTexture, objSamplerState 추가 및 파일 수정
	-> InitializeShaders()에서 layout 수정
	-> vertex.h 파일 수정
	-> 입력 Vertex 정보 수정
	-> RenderFrame()에서 samplerState 세팅
- 이후 출력하면 문자들이 나오는데, 이 이유는 우리가 Texture 세팅을 안했기 때문, 그래서 SpriteFont가 로드한 Texture가 그대로 출력되어 나온것
- 이를 해결하기 위해선
	-> Graphics 클래스에 WICTextureLoader.h include 후 myTexture 생성
	-> Data 폴더에 Textures 폴더 생성 후 원하는 사진 추가
	-> IntializeScene에서 myTexture 설정
	-> RenderFrame()에서 그림 그리기 전에 myTexture 세팅
	-> (이후 필요에 따라 WinMain에서 CoInitialize를 하고) 실행해보면 원하는 사진이 출력 됨

Indices:
- Vertex가 반복되는 것을 막기 위해 index를 저장하는 array를 생성
- 생성
	-> Graphics 클래스에 indicesBuffer 생성
	-> IntializeScene()에 indices array 생성 및 indicesBuffer 설정
	-> RenderFrame()에서 indicesBuffer 세팅 후 Draw()함수 대신 DrawIndexed() 함수 사용

Buffer Headers:
- Vertex와 Indices Buffer 생성 간소화하기 위한 작업
- Vertex Buffer Template
	-> VertexBuffer 헤더 생성 후 IntializeScene에서 했던 작업을 옮김
	-> Graphics 클래스에 VertexBuffer 객체 저장
	-> IntializeScene(), RenderFrame() 수정
- Index Buffer
	-> IndexBuffer 헤더 생성 (이 경우에는 template 사용 안함 - 항상 DWORD이기 때문) 후 IntializeScene에서 했던 작업을 옮김
	-> Graphics 클래스에 IndexBuffer 객체 저장
	-> IntializeScene(), RenderFrame() 수정

Constant Buffer:
- CPU와 GPU사이의 데이터 교환이 가능하도록 하는 버퍼
- 런타임에서 변수의 수정이 가능하다. (즉, 사진을 움직일 수 있다.)
- 생성
	-> vertexshader.hlsl 파일에 cbuffer 생성
	-> Graphics 클래스에 constantBuffer 생성
	-> ConstantBufferTypes 헤더 생성 후 CB_VS_vertexshader 구조체 생성
	-> InitializeScene()에서 constantBuffer 설정
	-> RenderFrame()에서 Constant Buffer를 업데이트